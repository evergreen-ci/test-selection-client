/*
Evergreen REST v2 API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AnnotationsAPIService AnnotationsAPI service
type AnnotationsAPIService service

type ApiTasksBuildIdAnnotationsGetRequest struct {
	ctx context.Context
	ApiService *AnnotationsAPIService
	buildId string
	fetchAllExecutions *string
}

// Fetches previous executions of the task if they are available
func (r ApiTasksBuildIdAnnotationsGetRequest) FetchAllExecutions(fetchAllExecutions string) ApiTasksBuildIdAnnotationsGetRequest {
	r.fetchAllExecutions = &fetchAllExecutions
	return r
}

func (r ApiTasksBuildIdAnnotationsGetRequest) Execute() ([]ModelAPITaskAnnotation, *http.Response, error) {
	return r.ApiService.TasksBuildIdAnnotationsGetExecute(r)
}

/*
TasksBuildIdAnnotationsGet List task annotations by build

Fetches the annotations for all the tasks in a build.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param buildId build_id
 @return ApiTasksBuildIdAnnotationsGetRequest
*/
func (a *AnnotationsAPIService) TasksBuildIdAnnotationsGet(ctx context.Context, buildId string) ApiTasksBuildIdAnnotationsGetRequest {
	return ApiTasksBuildIdAnnotationsGetRequest{
		ApiService: a,
		ctx: ctx,
		buildId: buildId,
	}
}

// Execute executes the request
//  @return []ModelAPITaskAnnotation
func (a *AnnotationsAPIService) TasksBuildIdAnnotationsGetExecute(r ApiTasksBuildIdAnnotationsGetRequest) ([]ModelAPITaskAnnotation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelAPITaskAnnotation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationsAPIService.TasksBuildIdAnnotationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{build_id}/annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"build_id"+"}", url.PathEscape(parameterValueToString(r.buildId, "buildId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchAllExecutions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch_all_executions", r.fetchAllExecutions, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksTaskIdAnnotationPatchRequest struct {
	ctx context.Context
	ApiService *AnnotationsAPIService
	taskId string
	object *ModelAPITaskAnnotation
	execution *int32
	upsert *bool
}

// parameters
func (r ApiTasksTaskIdAnnotationPatchRequest) Object(object ModelAPITaskAnnotation) ApiTasksTaskIdAnnotationPatchRequest {
	r.object = &object
	return r
}

// Can be set in lieu of specifying task_execution in the request body.
func (r ApiTasksTaskIdAnnotationPatchRequest) Execution(execution int32) ApiTasksTaskIdAnnotationPatchRequest {
	r.execution = &execution
	return r
}

// Will create a new annotation if task annotation isn&#39;t found and upsert is true.
func (r ApiTasksTaskIdAnnotationPatchRequest) Upsert(upsert bool) ApiTasksTaskIdAnnotationPatchRequest {
	r.upsert = &upsert
	return r
}

func (r ApiTasksTaskIdAnnotationPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.TasksTaskIdAnnotationPatchExecute(r)
}

/*
TasksTaskIdAnnotationPatch Create or update a new task annotation by appending

Creates a task annotation, or updates an existing task annotation, appending issues and suspected issues that are included in the update. A new annotation is created based if the annotation exists and if upsert is true. Task execution must be provided for this endpoint, either in the request body or set as a url parameter. If no task_execution is specified in the request body or in the url, a bad status error will be returned. Note that usage of this endpoint requires that the requesting user have security to modify task annotations. The user does not need to specify the source, it will be added automatically.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId task ID
 @return ApiTasksTaskIdAnnotationPatchRequest
*/
func (a *AnnotationsAPIService) TasksTaskIdAnnotationPatch(ctx context.Context, taskId string) ApiTasksTaskIdAnnotationPatchRequest {
	return ApiTasksTaskIdAnnotationPatchRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *AnnotationsAPIService) TasksTaskIdAnnotationPatchExecute(r ApiTasksTaskIdAnnotationPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationsAPIService.TasksTaskIdAnnotationPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{task_id}/annotation"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.object == nil {
		return nil, reportError("object is required and must be specified")
	}

	if r.execution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "execution", r.execution, "", "")
	}
	if r.upsert != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upsert", r.upsert, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.object
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTasksTaskIdAnnotationPutRequest struct {
	ctx context.Context
	ApiService *AnnotationsAPIService
	taskId string
	object *ModelAPITaskAnnotation
	execution *int32
}

// parameters
func (r ApiTasksTaskIdAnnotationPutRequest) Object(object ModelAPITaskAnnotation) ApiTasksTaskIdAnnotationPutRequest {
	r.object = &object
	return r
}

// Can be set in lieu of specifying task_execution in the request body.
func (r ApiTasksTaskIdAnnotationPutRequest) Execution(execution int32) ApiTasksTaskIdAnnotationPutRequest {
	r.execution = &execution
	return r
}

func (r ApiTasksTaskIdAnnotationPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.TasksTaskIdAnnotationPutExecute(r)
}

/*
TasksTaskIdAnnotationPut Create or update a new task annotation

Creates a task annotation, or updates an existing task annotation, overwriting any existing fields that are included in the update. The annotation is created based on the annotation specified in the request body. Task execution must be provided for this endpoint, either in the request body or set as a url parameter. If no task_execution is specified in the request body or in the url, a bad status error will be returned. Note that usage of this endpoint requires that the requesting user have security to modify task annotations. The user does not need to specify the source, it will be added automatically.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId task ID
 @return ApiTasksTaskIdAnnotationPutRequest
*/
func (a *AnnotationsAPIService) TasksTaskIdAnnotationPut(ctx context.Context, taskId string) ApiTasksTaskIdAnnotationPutRequest {
	return ApiTasksTaskIdAnnotationPutRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *AnnotationsAPIService) TasksTaskIdAnnotationPutExecute(r ApiTasksTaskIdAnnotationPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationsAPIService.TasksTaskIdAnnotationPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{task_id}/annotation"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.object == nil {
		return nil, reportError("object is required and must be specified")
	}

	if r.execution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "execution", r.execution, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.object
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTasksTaskIdAnnotationsGetRequest struct {
	ctx context.Context
	ApiService *AnnotationsAPIService
	taskId string
	execution *int32
	fetchAllExecutions *string
}

// The 0-based number corresponding to the execution of the task ID. Defaults to the latest execution
func (r ApiTasksTaskIdAnnotationsGetRequest) Execution(execution int32) ApiTasksTaskIdAnnotationsGetRequest {
	r.execution = &execution
	return r
}

// Fetches previous executions of the task if they are available
func (r ApiTasksTaskIdAnnotationsGetRequest) FetchAllExecutions(fetchAllExecutions string) ApiTasksTaskIdAnnotationsGetRequest {
	r.fetchAllExecutions = &fetchAllExecutions
	return r
}

func (r ApiTasksTaskIdAnnotationsGetRequest) Execute() ([]ModelAPITaskAnnotation, *http.Response, error) {
	return r.ApiService.TasksTaskIdAnnotationsGetExecute(r)
}

/*
TasksTaskIdAnnotationsGet Fetch task annotations

Returns a list containing the latest annotation for the given task, or null if there are no annotations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId task ID
 @return ApiTasksTaskIdAnnotationsGetRequest
*/
func (a *AnnotationsAPIService) TasksTaskIdAnnotationsGet(ctx context.Context, taskId string) ApiTasksTaskIdAnnotationsGetRequest {
	return ApiTasksTaskIdAnnotationsGetRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return []ModelAPITaskAnnotation
func (a *AnnotationsAPIService) TasksTaskIdAnnotationsGetExecute(r ApiTasksTaskIdAnnotationsGetRequest) ([]ModelAPITaskAnnotation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelAPITaskAnnotation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationsAPIService.TasksTaskIdAnnotationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{task_id}/annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.execution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "execution", r.execution, "", "")
	}
	if r.fetchAllExecutions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch_all_executions", r.fetchAllExecutions, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksTaskIdCreatedTicketPutRequest struct {
	ctx context.Context
	ApiService *AnnotationsAPIService
	taskId string
	object *ModelAPIIssueLink
}

// parameters
func (r ApiTasksTaskIdCreatedTicketPutRequest) Object(object ModelAPIIssueLink) ApiTasksTaskIdCreatedTicketPutRequest {
	r.object = &object
	return r
}

func (r ApiTasksTaskIdCreatedTicketPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.TasksTaskIdCreatedTicketPutExecute(r)
}

/*
TasksTaskIdCreatedTicketPut Send a newly created ticket for a task.

If a file ticket webhook is configured for a project, this endpoint should be used to let evergreen know when a ticket was filed for a task so that it can be stored and displayed to the user. The request body should include the ticket url and issue_key. Note that usage of this endpoint requires that the requesting user have security to modify task annotations. The user does not need to specify the source of the ticket, it will be added automatically.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId task ID
 @return ApiTasksTaskIdCreatedTicketPutRequest
*/
func (a *AnnotationsAPIService) TasksTaskIdCreatedTicketPut(ctx context.Context, taskId string) ApiTasksTaskIdCreatedTicketPutRequest {
	return ApiTasksTaskIdCreatedTicketPutRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *AnnotationsAPIService) TasksTaskIdCreatedTicketPutExecute(r ApiTasksTaskIdCreatedTicketPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationsAPIService.TasksTaskIdCreatedTicketPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{task_id}/created_ticket"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.object == nil {
		return nil, reportError("object is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.object
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTasksVersionIdAnnotationsGetRequest struct {
	ctx context.Context
	ApiService *AnnotationsAPIService
	versionId string
	fetchAllExecutions *string
}

// Fetches previous executions of the task if they are available
func (r ApiTasksVersionIdAnnotationsGetRequest) FetchAllExecutions(fetchAllExecutions string) ApiTasksVersionIdAnnotationsGetRequest {
	r.fetchAllExecutions = &fetchAllExecutions
	return r
}

func (r ApiTasksVersionIdAnnotationsGetRequest) Execute() ([]ModelAPITaskAnnotation, *http.Response, error) {
	return r.ApiService.TasksVersionIdAnnotationsGetExecute(r)
}

/*
TasksVersionIdAnnotationsGet List task annotations by version

Fetches the annotations for all the tasks in a version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param versionId version_id
 @return ApiTasksVersionIdAnnotationsGetRequest
*/
func (a *AnnotationsAPIService) TasksVersionIdAnnotationsGet(ctx context.Context, versionId string) ApiTasksVersionIdAnnotationsGetRequest {
	return ApiTasksVersionIdAnnotationsGetRequest{
		ApiService: a,
		ctx: ctx,
		versionId: versionId,
	}
}

// Execute executes the request
//  @return []ModelAPITaskAnnotation
func (a *AnnotationsAPIService) TasksVersionIdAnnotationsGetExecute(r ApiTasksVersionIdAnnotationsGetRequest) ([]ModelAPITaskAnnotation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelAPITaskAnnotation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationsAPIService.TasksVersionIdAnnotationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{version_id}/annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"version_id"+"}", url.PathEscape(parameterValueToString(r.versionId, "versionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fetchAllExecutions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch_all_executions", r.fetchAllExecutions, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
