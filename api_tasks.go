/*
Evergreen REST v2 API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TasksAPIService TasksAPI service
type TasksAPIService service

type ApiBuildsBuildIdTasksGetRequest struct {
	ctx context.Context
	ApiService *TasksAPIService
	buildId string
	startAt *string
	limit *int32
	fetchAllExecutions *bool
	fetchParentIds *bool
}

// The identifier of the task to start at in the pagination
func (r ApiBuildsBuildIdTasksGetRequest) StartAt(startAt string) ApiBuildsBuildIdTasksGetRequest {
	r.startAt = &startAt
	return r
}

// The number of tasks to be returned per page of pagination. Defaults to 100
func (r ApiBuildsBuildIdTasksGetRequest) Limit(limit int32) ApiBuildsBuildIdTasksGetRequest {
	r.limit = &limit
	return r
}

// Fetches previous executions of tasks if they are available
func (r ApiBuildsBuildIdTasksGetRequest) FetchAllExecutions(fetchAllExecutions bool) ApiBuildsBuildIdTasksGetRequest {
	r.fetchAllExecutions = &fetchAllExecutions
	return r
}

// Fetches the parent display task ID for each returned execution task
func (r ApiBuildsBuildIdTasksGetRequest) FetchParentIds(fetchParentIds bool) ApiBuildsBuildIdTasksGetRequest {
	r.fetchParentIds = &fetchParentIds
	return r
}

func (r ApiBuildsBuildIdTasksGetRequest) Execute() ([]ModelAPITask, *http.Response, error) {
	return r.ApiService.BuildsBuildIdTasksGetExecute(r)
}

/*
BuildsBuildIdTasksGet List tasks by build

List all tasks within a specific build.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param buildId the build ID
 @return ApiBuildsBuildIdTasksGetRequest
*/
func (a *TasksAPIService) BuildsBuildIdTasksGet(ctx context.Context, buildId string) ApiBuildsBuildIdTasksGetRequest {
	return ApiBuildsBuildIdTasksGetRequest{
		ApiService: a,
		ctx: ctx,
		buildId: buildId,
	}
}

// Execute executes the request
//  @return []ModelAPITask
func (a *TasksAPIService) BuildsBuildIdTasksGetExecute(r ApiBuildsBuildIdTasksGetRequest) ([]ModelAPITask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelAPITask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksAPIService.BuildsBuildIdTasksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/builds/{build_id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"build_id"+"}", url.PathEscape(parameterValueToString(r.buildId, "buildId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_at", r.startAt, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.fetchAllExecutions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch_all_executions", r.fetchAllExecutions, "", "")
	}
	if r.fetchParentIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch_parent_ids", r.fetchParentIds, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsProjectIdTaskExecutionsGetRequest struct {
	ctx context.Context
	ApiService *TasksAPIService
	projectId string
	taskName *string
	buildVariant *string
	startTime *string
	endTime *string
	requesters *[]string
}

// The task to return execution info for.
func (r ApiProjectsProjectIdTaskExecutionsGetRequest) TaskName(taskName string) ApiProjectsProjectIdTaskExecutionsGetRequest {
	r.taskName = &taskName
	return r
}

// The build variant to return task execution info for.
func (r ApiProjectsProjectIdTaskExecutionsGetRequest) BuildVariant(buildVariant string) ApiProjectsProjectIdTaskExecutionsGetRequest {
	r.buildVariant = &buildVariant
	return r
}

// Will only return execution info after this time. Format should be 2022-12-01T12:30:00.000Z
func (r ApiProjectsProjectIdTaskExecutionsGetRequest) StartTime(startTime string) ApiProjectsProjectIdTaskExecutionsGetRequest {
	r.startTime = &startTime
	return r
}

// If not provided, will default to the current time.
func (r ApiProjectsProjectIdTaskExecutionsGetRequest) EndTime(endTime string) ApiProjectsProjectIdTaskExecutionsGetRequest {
	r.endTime = &endTime
	return r
}

// If not provided, will default to gitter_request (versions created by git commit). Can also be github_pull_request, trigger_request (Project Trigger versions) , github_merge_request (GitHub merge queue), or ad_hoc (periodic builds)
func (r ApiProjectsProjectIdTaskExecutionsGetRequest) Requesters(requesters []string) ApiProjectsProjectIdTaskExecutionsGetRequest {
	r.requesters = &requesters
	return r
}

func (r ApiProjectsProjectIdTaskExecutionsGetRequest) Execute() (*ModelProjectTaskExecutionResp, *http.Response, error) {
	return r.ApiService.ProjectsProjectIdTaskExecutionsGetExecute(r)
}

/*
ProjectsProjectIdTaskExecutionsGet Get execution info for a task

Right now, this returns the number of times the given task has executed (i.e. succeeded or failed). Parameters should be passed into the JSON body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId the project ID
 @return ApiProjectsProjectIdTaskExecutionsGetRequest
*/
func (a *TasksAPIService) ProjectsProjectIdTaskExecutionsGet(ctx context.Context, projectId string) ApiProjectsProjectIdTaskExecutionsGetRequest {
	return ApiProjectsProjectIdTaskExecutionsGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ModelProjectTaskExecutionResp
func (a *TasksAPIService) ProjectsProjectIdTaskExecutionsGetExecute(r ApiProjectsProjectIdTaskExecutionsGetRequest) (*ModelProjectTaskExecutionResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelProjectTaskExecutionResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksAPIService.ProjectsProjectIdTaskExecutionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{project_id}/task_executions"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.taskName == nil {
		return localVarReturnValue, nil, reportError("taskName is required and must be specified")
	}
	if r.buildVariant == nil {
		return localVarReturnValue, nil, reportError("buildVariant is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "task_name", r.taskName, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "build_variant", r.buildVariant, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "", "")
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "", "")
	}
	if r.requesters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requesters", r.requesters, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsProjectIdTasksTaskNameGetRequest struct {
	ctx context.Context
	ApiService *TasksAPIService
	projectId string
	taskName string
	buildVariant *string
}

// If set, will only include tasks that have run on this build variant.
func (r ApiProjectsProjectIdTasksTaskNameGetRequest) BuildVariant(buildVariant string) ApiProjectsProjectIdTasksTaskNameGetRequest {
	r.buildVariant = &buildVariant
	return r
}

func (r ApiProjectsProjectIdTasksTaskNameGetRequest) Execute() ([]ModelAPITask, *http.Response, error) {
	return r.ApiService.ProjectsProjectIdTasksTaskNameGetExecute(r)
}

/*
ProjectsProjectIdTasksTaskNameGet Get tasks for a project

Returns the last set number of completed tasks that exist for a given project. Parameters should be passed into the JSON body. Ensure that a task name rather than a task ID is passed into the URL.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId the project ID
 @param taskName the task name
 @return ApiProjectsProjectIdTasksTaskNameGetRequest
*/
func (a *TasksAPIService) ProjectsProjectIdTasksTaskNameGet(ctx context.Context, projectId string, taskName string) ApiProjectsProjectIdTasksTaskNameGetRequest {
	return ApiProjectsProjectIdTasksTaskNameGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		taskName: taskName,
	}
}

// Execute executes the request
//  @return []ModelAPITask
func (a *TasksAPIService) ProjectsProjectIdTasksTaskNameGetExecute(r ApiProjectsProjectIdTasksTaskNameGetRequest) ([]ModelAPITask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelAPITask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksAPIService.ProjectsProjectIdTasksTaskNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{project_id}/tasks/{task_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"task_name"+"}", url.PathEscape(parameterValueToString(r.taskName, "taskName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.buildVariant
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest struct {
	ctx context.Context
	ApiService *TasksAPIService
	projectName string
	commitHash string
	startAt *string
	limit *int32
	variant *string
	variantRegex *string
	taskName *string
	status *string
}

// The identifier of the task to start at in the pagination
func (r ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest) StartAt(startAt string) ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest {
	r.startAt = &startAt
	return r
}

// The number of tasks to be returned per page of pagination. Defaults to 100
func (r ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest) Limit(limit int32) ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest {
	r.limit = &limit
	return r
}

// Only return tasks within this variant
func (r ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest) Variant(variant string) ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest {
	r.variant = &variant
	return r
}

// Only return tasks within variants that match this regex
func (r ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest) VariantRegex(variantRegex string) ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest {
	r.variantRegex = &variantRegex
	return r
}

// Only return tasks with this display name
func (r ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest) TaskName(taskName string) ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest {
	r.taskName = &taskName
	return r
}

// Only return tasks with this status
func (r ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest) Status(status string) ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest {
	r.status = &status
	return r
}

func (r ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest) Execute() ([]ModelAPITask, *http.Response, error) {
	return r.ApiService.ProjectsProjectNameRevisionsCommitHashTasksGetExecute(r)
}

/*
ProjectsProjectNameRevisionsCommitHashTasksGet List tasks by project and commit

List all tasks within a mainline commit of a given project (excludes patch tasks)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectName project name
 @param commitHash commit hash
 @return ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest
*/
func (a *TasksAPIService) ProjectsProjectNameRevisionsCommitHashTasksGet(ctx context.Context, projectName string, commitHash string) ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest {
	return ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest{
		ApiService: a,
		ctx: ctx,
		projectName: projectName,
		commitHash: commitHash,
	}
}

// Execute executes the request
//  @return []ModelAPITask
func (a *TasksAPIService) ProjectsProjectNameRevisionsCommitHashTasksGetExecute(r ApiProjectsProjectNameRevisionsCommitHashTasksGetRequest) ([]ModelAPITask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelAPITask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksAPIService.ProjectsProjectNameRevisionsCommitHashTasksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{project_name}/revisions/{commit_hash}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"project_name"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commit_hash"+"}", url.PathEscape(parameterValueToString(r.commitHash, "commitHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_at", r.startAt, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.variant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variant", r.variant, "", "")
	}
	if r.variantRegex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variant_regex", r.variantRegex, "", "")
	}
	if r.taskName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "task_name", r.taskName, "", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksTaskIdAbortPostRequest struct {
	ctx context.Context
	ApiService *TasksAPIService
	taskId string
}

func (r ApiTasksTaskIdAbortPostRequest) Execute() (*ModelAPITask, *http.Response, error) {
	return r.ApiService.TasksTaskIdAbortPostExecute(r)
}

/*
TasksTaskIdAbortPost Abort a task

Abort the task of the given ID. Can only be performed if the task is in progress.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId task ID
 @return ApiTasksTaskIdAbortPostRequest
*/
func (a *TasksAPIService) TasksTaskIdAbortPost(ctx context.Context, taskId string) ApiTasksTaskIdAbortPostRequest {
	return ApiTasksTaskIdAbortPostRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return ModelAPITask
func (a *TasksAPIService) TasksTaskIdAbortPostExecute(r ApiTasksTaskIdAbortPostRequest) (*ModelAPITask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelAPITask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksAPIService.TasksTaskIdAbortPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{task_id}/abort"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksTaskIdBuildTaskLogsGetRequest struct {
	ctx context.Context
	ApiService *TasksAPIService
	taskId string
	execution *int32
	type_ *string
	start *string
	end *string
	lineLimit *int32
	tailLimit *int32
	printTime *bool
	printPriority *bool
	paginate *bool
}

// The 0-based number corresponding to the execution of the task ID. Defaults to the latest execution.
func (r ApiTasksTaskIdBuildTaskLogsGetRequest) Execution(execution int32) ApiTasksTaskIdBuildTaskLogsGetRequest {
	r.execution = &execution
	return r
}

// Task log type. Must be one of: &#x60;agent_log&#x60;, &#x60;system_log&#x60;, &#x60;task_log&#x60;, &#x60;all_logs&#x60;. Defaults to &#x60;all_logs&#x60;.
func (r ApiTasksTaskIdBuildTaskLogsGetRequest) Type_(type_ string) ApiTasksTaskIdBuildTaskLogsGetRequest {
	r.type_ = &type_
	return r
}

// Start of targeted time interval (inclusive) in RFC3339 format. Defaults to the first timestamp of the requested logs.
func (r ApiTasksTaskIdBuildTaskLogsGetRequest) Start(start string) ApiTasksTaskIdBuildTaskLogsGetRequest {
	r.start = &start
	return r
}

// End of targeted time interval (inclusive) in RFC3339 format. Defaults to the last timestamp of the requested logs.
func (r ApiTasksTaskIdBuildTaskLogsGetRequest) End(end string) ApiTasksTaskIdBuildTaskLogsGetRequest {
	r.end = &end
	return r
}

// If set greater than 0, limits the number of log lines returned.
func (r ApiTasksTaskIdBuildTaskLogsGetRequest) LineLimit(lineLimit int32) ApiTasksTaskIdBuildTaskLogsGetRequest {
	r.lineLimit = &lineLimit
	return r
}

// If set greater than 0, returns the last N log lines.
func (r ApiTasksTaskIdBuildTaskLogsGetRequest) TailLimit(tailLimit int32) ApiTasksTaskIdBuildTaskLogsGetRequest {
	r.tailLimit = &tailLimit
	return r
}

// If set to true, returns log lines prefixed with their timestamp.
func (r ApiTasksTaskIdBuildTaskLogsGetRequest) PrintTime(printTime bool) ApiTasksTaskIdBuildTaskLogsGetRequest {
	r.printTime = &printTime
	return r
}

// If set to true, returns log lines prefixed with their priority.
func (r ApiTasksTaskIdBuildTaskLogsGetRequest) PrintPriority(printPriority bool) ApiTasksTaskIdBuildTaskLogsGetRequest {
	r.printPriority = &printPriority
	return r
}

// If set to true, paginates the response.
func (r ApiTasksTaskIdBuildTaskLogsGetRequest) Paginate(paginate bool) ApiTasksTaskIdBuildTaskLogsGetRequest {
	r.paginate = &paginate
	return r
}

func (r ApiTasksTaskIdBuildTaskLogsGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.TasksTaskIdBuildTaskLogsGetExecute(r)
}

/*
TasksTaskIdBuildTaskLogsGet Get task logs for a task.

Fetch task logs by task ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId Task ID.
 @return ApiTasksTaskIdBuildTaskLogsGetRequest
*/
func (a *TasksAPIService) TasksTaskIdBuildTaskLogsGet(ctx context.Context, taskId string) ApiTasksTaskIdBuildTaskLogsGetRequest {
	return ApiTasksTaskIdBuildTaskLogsGetRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return string
func (a *TasksAPIService) TasksTaskIdBuildTaskLogsGetExecute(r ApiTasksTaskIdBuildTaskLogsGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksAPIService.TasksTaskIdBuildTaskLogsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{task_id}/build/TaskLogs"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.execution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "execution", r.execution, "", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "", "")
	}
	if r.lineLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "line_limit", r.lineLimit, "", "")
	}
	if r.tailLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tail_limit", r.tailLimit, "", "")
	}
	if r.printTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "print_time", r.printTime, "", "")
	}
	if r.printPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "print_priority", r.printPriority, "", "")
	}
	if r.paginate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paginate", r.paginate, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksTaskIdBuildTestLogsPathGetRequest struct {
	ctx context.Context
	ApiService *TasksAPIService
	taskId string
	path string
	execution *int32
	logsToMerge *string
	start *string
	end *string
	lineLimit *int32
	tailLimit *int32
	printTime *bool
	printPriority *bool
	paginate *bool
}

// The 0-based number corresponding to the execution of the task ID. Defaults to the latest execution.
func (r ApiTasksTaskIdBuildTestLogsPathGetRequest) Execution(execution int32) ApiTasksTaskIdBuildTestLogsPathGetRequest {
	r.execution = &execution
	return r
}

// Test log path, relative to the task&#39;s test log directory, to merge with test log specified in the URL path. Can be a prefix. Merging is stable and timestamp-based. Repeat the parameter key if more than one value.
func (r ApiTasksTaskIdBuildTestLogsPathGetRequest) LogsToMerge(logsToMerge string) ApiTasksTaskIdBuildTestLogsPathGetRequest {
	r.logsToMerge = &logsToMerge
	return r
}

// Start of targeted time interval (inclusive) in RFC3339 format. Defaults to the first timestamp of the test log specified in the URL path.
func (r ApiTasksTaskIdBuildTestLogsPathGetRequest) Start(start string) ApiTasksTaskIdBuildTestLogsPathGetRequest {
	r.start = &start
	return r
}

// End of targeted time interval (inclusive) in RFC3339 format. Defaults to the last timestamp of the test log specified in the URL path.
func (r ApiTasksTaskIdBuildTestLogsPathGetRequest) End(end string) ApiTasksTaskIdBuildTestLogsPathGetRequest {
	r.end = &end
	return r
}

// If set greater than 0, limits the number of log lines returned.
func (r ApiTasksTaskIdBuildTestLogsPathGetRequest) LineLimit(lineLimit int32) ApiTasksTaskIdBuildTestLogsPathGetRequest {
	r.lineLimit = &lineLimit
	return r
}

// If set greater than 0, returns the last N log lines.
func (r ApiTasksTaskIdBuildTestLogsPathGetRequest) TailLimit(tailLimit int32) ApiTasksTaskIdBuildTestLogsPathGetRequest {
	r.tailLimit = &tailLimit
	return r
}

// If set to true, returns log lines prefixed with their timestamp.
func (r ApiTasksTaskIdBuildTestLogsPathGetRequest) PrintTime(printTime bool) ApiTasksTaskIdBuildTestLogsPathGetRequest {
	r.printTime = &printTime
	return r
}

// If set to true, returns log lines prefixed with their priority.
func (r ApiTasksTaskIdBuildTestLogsPathGetRequest) PrintPriority(printPriority bool) ApiTasksTaskIdBuildTestLogsPathGetRequest {
	r.printPriority = &printPriority
	return r
}

// If set to true, paginates the response.
func (r ApiTasksTaskIdBuildTestLogsPathGetRequest) Paginate(paginate bool) ApiTasksTaskIdBuildTestLogsPathGetRequest {
	r.paginate = &paginate
	return r
}

func (r ApiTasksTaskIdBuildTestLogsPathGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.TasksTaskIdBuildTestLogsPathGetExecute(r)
}

/*
TasksTaskIdBuildTestLogsPathGet Get test logs for a task.

Fetch test logs by task ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId Task ID.
 @param path Test log path relative to the task's test logs directory.
 @return ApiTasksTaskIdBuildTestLogsPathGetRequest
*/
func (a *TasksAPIService) TasksTaskIdBuildTestLogsPathGet(ctx context.Context, taskId string, path string) ApiTasksTaskIdBuildTestLogsPathGetRequest {
	return ApiTasksTaskIdBuildTestLogsPathGetRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
		path: path,
	}
}

// Execute executes the request
//  @return string
func (a *TasksAPIService) TasksTaskIdBuildTestLogsPathGetExecute(r ApiTasksTaskIdBuildTestLogsPathGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksAPIService.TasksTaskIdBuildTestLogsPathGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{task_id}/build/TestLogs/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.execution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "execution", r.execution, "", "")
	}
	if r.logsToMerge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logs_to_merge", r.logsToMerge, "", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "", "")
	}
	if r.lineLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "line_limit", r.lineLimit, "", "")
	}
	if r.tailLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tail_limit", r.tailLimit, "", "")
	}
	if r.printTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "print_time", r.printTime, "", "")
	}
	if r.printPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "print_priority", r.printPriority, "", "")
	}
	if r.paginate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paginate", r.paginate, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksTaskIdGeneratedTasksGetRequest struct {
	ctx context.Context
	ApiService *TasksAPIService
	taskId string
}

func (r ApiTasksTaskIdGeneratedTasksGetRequest) Execute() ([]ModelAPIGeneratedTaskInfo, *http.Response, error) {
	return r.ApiService.TasksTaskIdGeneratedTasksGetExecute(r)
}

/*
TasksTaskIdGeneratedTasksGet Get info about generated tasks

Fetch basic info about all tasks generated by a task that ran generate.tasks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId task ID
 @return ApiTasksTaskIdGeneratedTasksGetRequest
*/
func (a *TasksAPIService) TasksTaskIdGeneratedTasksGet(ctx context.Context, taskId string) ApiTasksTaskIdGeneratedTasksGetRequest {
	return ApiTasksTaskIdGeneratedTasksGetRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return []ModelAPIGeneratedTaskInfo
func (a *TasksAPIService) TasksTaskIdGeneratedTasksGetExecute(r ApiTasksTaskIdGeneratedTasksGetRequest) ([]ModelAPIGeneratedTaskInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelAPIGeneratedTaskInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksAPIService.TasksTaskIdGeneratedTasksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{task_id}/generated_tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksTaskIdGetRequest struct {
	ctx context.Context
	ApiService *TasksAPIService
	taskId string
	execution *int32
	fetchAllExecutions *string
}

// The 0-based number corresponding to the execution of the task ID. Defaults to the latest execution
func (r ApiTasksTaskIdGetRequest) Execution(execution int32) ApiTasksTaskIdGetRequest {
	r.execution = &execution
	return r
}

// Fetches previous executions of the task if they are available
func (r ApiTasksTaskIdGetRequest) FetchAllExecutions(fetchAllExecutions string) ApiTasksTaskIdGetRequest {
	r.fetchAllExecutions = &fetchAllExecutions
	return r
}

func (r ApiTasksTaskIdGetRequest) Execute() (*ModelAPITask, *http.Response, error) {
	return r.ApiService.TasksTaskIdGetExecute(r)
}

/*
TasksTaskIdGet Get a single task

Fetch a single task using its ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId task ID
 @return ApiTasksTaskIdGetRequest
*/
func (a *TasksAPIService) TasksTaskIdGet(ctx context.Context, taskId string) ApiTasksTaskIdGetRequest {
	return ApiTasksTaskIdGetRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return ModelAPITask
func (a *TasksAPIService) TasksTaskIdGetExecute(r ApiTasksTaskIdGetRequest) (*ModelAPITask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelAPITask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksAPIService.TasksTaskIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{task_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.execution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "execution", r.execution, "", "")
	}
	if r.fetchAllExecutions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fetch_all_executions", r.fetchAllExecutions, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksTaskIdPatchRequest struct {
	ctx context.Context
	ApiService *TasksAPIService
	taskId string
	object *RouteTaskExecutionPatchHandler
}

// parameters
func (r ApiTasksTaskIdPatchRequest) Object(object RouteTaskExecutionPatchHandler) ApiTasksTaskIdPatchRequest {
	r.object = &object
	return r
}

func (r ApiTasksTaskIdPatchRequest) Execute() (*ModelAPITask, *http.Response, error) {
	return r.ApiService.TasksTaskIdPatchExecute(r)
}

/*
TasksTaskIdPatch Change a task's execution status

Change the current execution status of a task. Accepts a JSON body with the new task status to be set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId task ID
 @return ApiTasksTaskIdPatchRequest
*/
func (a *TasksAPIService) TasksTaskIdPatch(ctx context.Context, taskId string) ApiTasksTaskIdPatchRequest {
	return ApiTasksTaskIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return ModelAPITask
func (a *TasksAPIService) TasksTaskIdPatchExecute(r ApiTasksTaskIdPatchRequest) (*ModelAPITask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelAPITask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksAPIService.TasksTaskIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{task_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.object == nil {
		return localVarReturnValue, nil, reportError("object is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.object
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksTaskIdRestartPostRequest struct {
	ctx context.Context
	ApiService *TasksAPIService
	taskId string
	object *RouteTaskRestartHandler
}

// parameters
func (r ApiTasksTaskIdRestartPostRequest) Object(object RouteTaskRestartHandler) ApiTasksTaskIdRestartPostRequest {
	r.object = &object
	return r
}

func (r ApiTasksTaskIdRestartPostRequest) Execute() (*ModelAPITask, *http.Response, error) {
	return r.ApiService.TasksTaskIdRestartPostExecute(r)
}

/*
TasksTaskIdRestartPost Restart a task

Restarts the task of the given ID. Can only be performed if the task is finished.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId task ID
 @return ApiTasksTaskIdRestartPostRequest
*/
func (a *TasksAPIService) TasksTaskIdRestartPost(ctx context.Context, taskId string) ApiTasksTaskIdRestartPostRequest {
	return ApiTasksTaskIdRestartPostRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return ModelAPITask
func (a *TasksAPIService) TasksTaskIdRestartPostExecute(r ApiTasksTaskIdRestartPostRequest) (*ModelAPITask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelAPITask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksAPIService.TasksTaskIdRestartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{task_id}/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.object
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-User"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-User"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
